{"name":"Webbit-metrics","tagline":"Metrics meets Webbit","body":"# webbit-metrics\r\n\r\n[![Build Status](https://travis-ci.org/kouphax/webbit-metrics.png?branch=master)](https://travis-ci.org/kouphax/webbit-metrics)\r\n\r\nA [Metrics](http://metrics.codahale.com) backed [Webbit](http://webbitserver.org) Server for great good. __webbit-metrics__ acts as a companion server that can be run alongside other simple services.  This is heavily inspired by the approach that [Twitter](http://twitter.com) take with [Finagle](twitter.github.io/finagle/) and [Ostrich](https://github.com/twitter/ostrich)\r\n\r\n## Getting It\r\n\r\n### Maven\r\n\r\nRepository\r\n\r\n    <repository>\r\n        <id>webbit-metrics-repo</id>\r\n        <url>https://raw.github.com/kouphax/webbit-metrics/mvn/</url>\r\n    </repository>\r\n\r\nDependency\r\n\r\n    <dependency>\r\n      <groupId>org.webbitserver</groupId>\r\n      <artifactId>webbit-metrics</artifactId>\r\n      <version>0.2-SNAPSHOT</version>\r\n    </dependency>\r\n    \r\n### SBT\r\n\r\nResolver\r\n\r\n\t\"webbit-metrics\" at \"https://raw.github.com/kouphax/webbit-metrics/mvn/\"\r\n    \r\nDependency\r\n\r\n    \"org.webbitserver\" % \"webbit-metrics\" % \"0.2-SNAPSHOT\"\r\n\r\n## AdminWebServer\r\n\r\nLets assume we have a [Webbit](http://webbitserver.org) web server already.  Any sort of JVM based Web Server will do but [Webbit](http://webbitserver.org) ones give you a little bit more as we will see later. \r\n\r\n    import org.webbitserver.*;\r\n    import org.webbitserver.netty.NettyWebServer;\r\n    \r\n    public class MyLovelyGreeterService {\r\n        public static void main(String[] args) throws Exception {\r\n    \r\n            final NettyWebServer server = new NettyWebServer(9996);\r\n    \r\n            server.add(\"/\", new HttpHandler(){\r\n                @Override\r\n                public void handleHttpRequest(HttpRequest request, HttpResponse response, HttpControl control) throws Exception {\r\n                    response.content(\"Hello World\").end();\r\n                }\r\n            });\r\n    \r\n            server.start().get();\r\n            System.out.println(\"Server listening on port \" + 9996);\r\n        }\r\n    }\r\n    \r\nIf we want to monitor or instrument this service we can create an instance of an `AdminWebServer` that can run alongside it and collect metrics that our service generates.\r\n\r\n\tfinal AdminWebServer admin = new AdminWebServer(server, 9997);\r\n    admin.start().get();\r\n    \r\nBy adding these lines we end up with another server running on port `9997` that gives us,\r\n\r\n- Basic monitoring of the JVM & Threads\r\n- Ping service to check our service is reachable\r\n- Ability to `start`, `stop` & `restart` our service (passing the service is optional for non-[Webbit](http://webbitserver.org) services).\r\n\r\nThis service also exposes its own `HealthCheckRegistry` & `MetricRegistry` that can be used by your service to monitor the health of and collect valuable application & business metrics for your service.\r\n\r\n### Metrics\r\n\r\nWhen an `AdminWebServer` is created it will create its own instance of a `MetricRegistry` that can be accessed via `admin.metrics`.  So lets add some metrics to our service.\r\n\r\n    server.add(\"/\", new HttpHandler(){\r\n        @Override\r\n        public void handleHttpRequest(HttpRequest request, HttpResponse response, HttpControl control) throws Exception {\r\n            admin.metrics.counter(\"hit-count\").inc();\r\n            response.content(\"Hello World\").end();\r\n        }\r\n    });\r\n    \r\nSo we added `admin.metrics.counter(\"hit-count\").inc();` which will increment the counter everytime someone hits that endpoint.  If we run the servers and go to [`http://localhost:9996`](http://localhost:9996) then [`http://localhost:9997/metrics`](http://127.0.0.1:9997/metrics) we should see a JSON response like this,\r\n\r\n    {\r\n    \tversion: \"3.0.0\",\r\n    \tgauges: { },\r\n    \tcounters: {\r\n    \t\thit-count: {\r\n    \t\t\tcount: 1\r\n    \t\t}\r\n    \t},\r\n    \thistograms: { },\r\n    \tmeters: { },\r\n    \ttimers: { }\r\n    }\r\n\r\nThis is just a raw response from [Metrics](http://metrics.codahale.com), no need for any special sugar or transformation.  The `AdminWebServer` registry is a vanilla [Metrics](http://metrics.codahale.com) `MetricRegistry` and so supports all of [Metrics metrics](http://metrics.codahale.com/manual/core/) like [Gauges](http://metrics.codahale.com/manual/core/#gauges), [Counters](http://metrics.codahale.com/manual/core/#counters), [Histograms](http://metrics.codahale.com/manual/core/#histograms), [Meters](http://metrics.codahale.com/manual/core/#meters) and [Timers](http://metrics.codahale.com/manual/core/#timers).\r\n\r\n### Healthchecks\r\n\r\nIf your service relies on a database connection or some external service to function then `HealthChecks` help monitor that these things are actually reachable and working as expected.  You can add a healthcheck to the registry easily,\r\n\r\n    admin.healthchecks.register(\"randomly-unhealthy\", new HealthCheck() {\r\n        @Override\r\n        protected Result check() throws Exception {\r\n            final Boolean unhealthy = Math.random() < 0.5;\r\n            \r\n            if(unhealthy){\r\n                return Result.unhealthy(\"I've decided to have a sick day\");\r\n            }\r\n            \r\n            return Result.healthy();\r\n        }\r\n    });\r\n    \r\nThis example is horribly contrived but it serves its purpose.  Hitting [`http://localhost:9997/healthchecks`](http://127.0.0.1:9997/healthchecks) will run all registered healthchecks and return a JSON response,\r\n\r\n    {\r\n      randomly-unhealthy: {\r\n        healthy: false,\r\n        message: \"I've decided to have a sick day\"\r\n      }\r\n    }\r\n    \r\nIt will return an approximate HTTP Status code as well (`200 - OK` if everything is healthy, `500 - Internal Server Error` if these is something up and `501 - Not Implemented` if there are no registered healthchecks.\r\n\r\n### Ping\r\n\r\nHitting [`http://localhost:9997/ping`](http://127.0.0.1:9997/ping) will simply return a `200 - OK` response with plain text body containing `pong`.  This is useful in situations where you want to know if a machine or service is actually still around and reachable\r\n\r\n### Thread Dump & JVM Metrics\r\n\r\n[`http://localhost:9997/jvm`](http://127.0.0.1:9997/jvm) & [`http://localhost:9997/dump`](http://127.0.0.1:9997/dump) will give you some JVM metrics and Thread Dumps respectivley.\r\n\r\n### Server Control\r\n\r\nIf you pass in an instance of a [Webbit](http://webbitserver.org) server you have some control over the running of that service. \r\n\r\n- [`/start`](http://127.0.0.1:9997/start) - Starts the service.  Throws if the service is already started.\r\n- [`/stop`](http://127.0.0.1:9997/stop) - Stops the service.\r\n- [`/restart`](http://127.0.0.1:9997/restart) - Stops and then Starts the service.\r\n\r\n### Tasks\r\n\r\nTasks are arbitrary bits of code that can be run at any time from your `AdminWebServer` instance.  You can register as `Task` against the `TaskRegistry` instance created along with your `AdminWebServer` instance.\r\n\r\n    admin.tasks.register(\"seed-database\", new Task() {\r\n        @Override\r\n        public void execute() throws Exception {\r\n            // seed the database with some data\r\n        }\r\n    });\r\n    \r\nBrowsing to [/tasks](http://localhost:9997/tasks) will list available tasks and passing a `name` parameter in the querystring of a task will run that task e.g. [/tasks?name=seed-database](http://localhost:9997/tasks?name=seed-database).\r\n\r\nAny exceptions thrown in the course of running a task will be piped out to the browser.\r\n\r\n## InstrumentedMiddleware\r\n\r\n`InstrumentedMiddleware` is a Webbit handler that provides some basic metrics for requests.  Placing it at the head of your middleware stack for all requests in a [Webbit](http://webbitserver.org) will monitor the entire request chain\r\n\r\n    server.add(new InstrumentationMiddleware(\"my-lovely-greeter-service\", admin.metrics));\r\n    server.add(...);\r\n    server.add(...);\r\n    server.add(\"/\", new HttpHandler(){\r\n        @Override\r\n        public void handleHttpRequest(HttpRequest request, HttpResponse response, HttpControl control) throws Exception {\r\n            response.content(\"Hello World\").end();\r\n        }\r\n    });\r\n\r\nYou can optionally pass in a `handlerName` string as a first parameter and this will be appended to the instrumented metrics (useful if you have multiple handlers going to the same metrics registry).\r\n\r\nThe following metrics are provided by `InstrumentedMiddleware`\r\n\r\n- `active-request` counter - number of currently active requests\r\n- Meters for HTTP statuses\r\n  - `status.badRequest` (HTTP Status 400)\r\n  - `status.created` (HTTP Status 201)\r\n  - `status.noContent` (HTTP Status 204)\r\n  - `status.notFound` (HTTP Status 404)\r\n  - `status.ok` (HTTP Status 200)\r\n  - `status.serverError` (HTTP Status 500)\r\n  - `status.` (All other HTTP Statuses)\r\n- `request` timer - time based stats for request processing time\r\n\r\nThese will be available under [/metrics](http://localhost:9996/metrics).\r\n","google":"UA-19143623-16","note":"Don't delete this file! It's used internally to help with page regeneration."}